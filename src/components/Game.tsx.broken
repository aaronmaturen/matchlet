import React, { useState, useEffect, useCallback, useRef } from "react";
import Card from "./Card";
import GameSetupModal from "./GameSetupModal";
import { getAvatarUrl } from "../assets";
import WebRTCService from "../services/WebRTCService";
import { ConnectionStatus, GameState } from "../types/WebRTCTypes";
import "./Avatar.css";

// Game component for the Matchlet game

interface GameProps {
  triggerReset: boolean;
  onResetComplete: () => void;
  gameMode?: {
    mode: string;
    roomId?: string;
    isHost?: boolean;
  };
}

interface CardType {
  id: number;
  value: number;
  isFlipped: boolean;
  isMatched: boolean;
}

interface PlayerType {
  name: string;
  color: string;
  avatar: string;
}

interface OnlineStatusType {
  connected: boolean;
  roomId: string | null;
  isHost: boolean;
  players: string[];
  error: string | null;
  connectionStatus?: ConnectionStatus;
}

interface GameConfigType {
  boardSize: string;
  gridCols: number;
  gridRows: number;
  players: PlayerType[];
  cardset: string;
}

const Game = ({ triggerReset, onResetComplete, gameMode }: GameProps) => {
  // WebRTC service for online play
  const webRTCServiceRef = useRef<WebRTCService | null>(null);
  const [onlineStatus, setOnlineStatus] = useState<OnlineStatusType>({
    connected: false,
    roomId: null,
    isHost: false,
    players: [],
    error: null,
  });
  const [cards, setCards] = useState<CardType[]>([]);
  const [flippedCards, setFlippedCards] = useState<number[]>([]);
  const [matchedSets, setMatchedSets] = useState<number[]>([]);
  const [canFlipThird, setCanFlipThird] = useState(false);
  const [_score, setScore] = useState<number>(0); // Using underscore prefix to indicate intentionally unused state
  const [moves, setMoves] = useState<number>(0);
  const [modalOpened, setModalOpened] = useState<boolean>(true);
  const [gameConfig, setGameConfig] = useState<GameConfigType>({
    boardSize: "md",
    gridCols: 6,
    gridRows: 3,
    players: [
      {
        name: "Player 1",
        color: "#FF5733",
        avatar: "1.svg",
      },
    ],
    cardset: "animals", // Default cardset
  });

  // Available avatars in public/avatars directory
  // Using underscore prefix to indicate intentionally unused variable
  const _avatars = [
    "0201e35304ee6e58.svg",
    "069d87858be0162d.svg",
    "19615c04fd12819a.svg",
    "19e4a684452bef8c.svg",
    "28924ef7f7f679e8.svg",
    "3258508ba5a1be0f.svg",
    "3f459c50f96a77a4.svg",
    "69e054956e831eb1.svg",
    "6d6a2afc46152f67.svg",
    "776003a115f3458d.svg",
    "7cede0e7a110b709.svg",
    "854fad09bd8676d4.svg",
    "97ce7cd8b8e90dbd.svg",
    "9a8e6e3027d89157.svg",
    "9ac234827d3666fb.svg",
    "a033f14526b48510.svg",
    "a41d42a2a72908db.svg",
    "a606efd924376295.svg",
    "bf36a7596b17be6d.svg",
    "d498bc72ffc72c9b.svg",
    "f0cb03da1b59b63f.svg",
    "f20d5dc563edbac9.svg",
  ];
  const [currentPlayerIndex, setCurrentPlayerIndex] = useState(0);
  const [playerScores, setPlayerScores] = useState<number[]>([0]);

  // Helper function to generate cards with values that can form triplets
  const generateCards = useCallback(() => {
    // Calculate total cards based on grid size
    const totalCards = gameConfig.gridCols * gameConfig.gridRows;

    // Determine how many unique values we need (each appears 3 times)
    const uniqueValues = Math.floor(totalCards / 3);

    // For cardset randomization - we'll use a larger pool of possible card values
    // We have 53 images in the monsters directory and 50 in animals
    const maxCardValue = gameConfig.cardset === "monsters" ? 53 : 50;

    // Create an array of possible card values (1-20) and shuffle it
    const possibleValues = Array.from(
      { length: maxCardValue },
      (_, i) => i + 1
    ).sort(() => Math.random() - 0.5);

    // Take just the number of unique values we need from the shuffled array
    const selectedValues = possibleValues.slice(0, uniqueValues);

    // Create sets of cards (each value appearing 3 times)
    const values: number[] = [];
    for (const value of selectedValues) {
      values.push(value, value, value); // Each value appears 3 times
    }

    // If we have remaining slots, add some extra cards
    const remaining = totalCards - values.length;
    if (remaining > 0 && selectedValues.length > 0) {
      for (let i = 0; i < remaining; i++) {
        values.push(selectedValues[0]); // Use the first selected value for extras
      }
    }

    // Shuffle the values
    const shuffledValues = [...values].sort(() => Math.random() - 0.5);

    // Create card objects
    const newCards = shuffledValues.map((value, index) => ({
      id: index,
      value,
      isFlipped: false,
      isMatched: false,
    }));

    return newCards;
  }, [gameConfig.gridCols, gameConfig.gridRows, gameConfig.cardset]);

  // Wrap moveToNextPlayer in useCallback to avoid dependency issues
  const moveToNextPlayer = useCallback(() => {
    setCurrentPlayerIndex(
      (prevIndex) => (prevIndex + 1) % gameConfig.players.length
    );
  }, [gameConfig.players.length]);

  // Helper function to determine if a card is disabled
  const isCardDisabled = (id: number): boolean => {
    const card = cards.find((card) => card.id === id);
    if (!card) return true; // If card not found, consider it disabled
    return (
      card.isMatched ||
      flippedCards.length === 3 ||
      (flippedCards.length === 2 && !canFlipThird)
    );
  };

  // Helper function to get the grid columns class based on grid size with responsive breakpoints
  const getGridColsClass = (cols) => {
    switch (cols) {
      case 3:
        return "grid-cols-2 sm:grid-cols-3";
      case 4:
        return "grid-cols-2 sm:grid-cols-3 md:grid-cols-4";
      case 5:
        return "grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5";
      case 6:
        return "grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-6";
      case 8:
        return "grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-6 xl:grid-cols-8";
      case 9:
        return "grid-cols-2 sm:grid-cols-3 md:grid-cols-5 lg:grid-cols-6 xl:grid-cols-9";
      default:
        return "grid-cols-2 sm:grid-cols-3 md:grid-cols-4";
    }
  };

  // Handle card click
  const handleCardClick = (id: number) => {
    // If we already have 2 cards flipped and can't flip a third, or we have 3 cards flipped, do nothing
    if (
      (flippedCards.length === 2 && !canFlipThird) ||
      flippedCards.length === 3
    ) {
      return;
    }

    // In online mode, only allow the current player to make moves
    if (gameMode?.mode === "online" && currentPlayerIndex !== 0) {
      return;
    }

    // Flip the card
    setCards(
      cards.map((card) =>
        card.id === id ? { ...card, isFlipped: true } : card
      )
    );

    // Add to flipped cards
    setFlippedCards([...flippedCards, id]);

    // Increment moves if this is the first or third card
    if (flippedCards.length === 0 || flippedCards.length === 2) {
      setMoves((prevMoves) => prevMoves + 1);
    }

    // In online mode, sync the game state
    if (gameMode?.mode === "online" && webRTCServiceRef.current) {
      // Small delay to ensure state updates have been processed
      setTimeout(() => {
        webRTCServiceRef.current.sendGameState({
          cards: cards.map((card) =>
            card.id === id ? { ...card, isFlipped: true } : card
          ),
          flippedCards: [...flippedCards, id],
          matchedSets,
          playerScores,
          currentPlayerIndex,
          moves:
            flippedCards.length === 0 || flippedCards.length === 2
              ? moves + 1
              : moves,
        });
      }, 50);
    }
  };

  // Check for matches when flipped cards change
  useEffect(() => {
    // Don't do anything if no cards are flipped
    if (flippedCards.length === 0) return;

    // If we have 2 cards flipped, check if they match
    if (flippedCards.length === 2) {
      const firstCardId = flippedCards[0];
      const secondCardId = flippedCards[1];
      const firstCard = cards.find((card) => card.id === firstCardId);
      const secondCard = cards.find((card) => card.id === secondCardId);

      // If they match, allow flipping a third card
      if (firstCard && secondCard && firstCard.value === secondCard.value) {
        setCanFlipThird(true);
      } else {
        // If they don't match, flip them back after a delay
        const timer = setTimeout(() => {
          setCards(
            cards.map((card) => {
              if (flippedCards.includes(card.id)) {
                return { ...card, isFlipped: false };
              }
              return card;
            })
          );
          setFlippedCards([]);
          moveToNextPlayer();
        }, 1000);

        return () => clearTimeout(timer);
      }
    }

    // If we have 3 cards flipped, check if they all match
    if (flippedCards.length === 3) {
      const firstCardId = flippedCards[0];
      const secondCardId = flippedCards[1];
      const thirdCardId = flippedCards[2];

      const firstCard = cards.find((card) => card.id === firstCardId);
      const secondCard = cards.find((card) => card.id === secondCardId);
      const thirdCard = cards.find((card) => card.id === thirdCardId);
      
      if (!firstCard || !secondCard || !thirdCard) return;

      // Check if all three cards have the same value
      const isMatch =
        firstCard &&
        secondCard &&
        thirdCard &&
        firstCard.value === secondCard.value &&
        secondCard.value === thirdCard.value;

      // Use a timeout to handle the match or non-match
      const timer = setTimeout(
        () => {
          if (isMatch) {
            // Mark the cards as matched
            setCards(
              cards.map((card) => {
                if (flippedCards.includes(card.id)) {
                  return { ...card, isMatched: true };
                }
                return card;
              })
            );

            // Add to matched sets if not already included
            setMatchedSets((prev) => {
              if (!prev.includes(firstCard.value)) {
                return [...prev, firstCard.value];
              }
              return prev;
            });

            // Add 1 point to score (1 point per match)
            setScore((prev) => prev + 1);

            // Add 1 point to current player's score (1 point per match)
            setPlayerScores((prev) => {
              const newScores = [...prev];
              newScores[currentPlayerIndex] = newScores[currentPlayerIndex] + 1;
              return newScores;
            });
          } else {
            // If they don't match, flip them back
            setCards(
              cards.map((card) => {
                if (flippedCards.includes(card.id)) {
                  return { ...card, isFlipped: false };
                }
                return card;
              })
            );
            moveToNextPlayer();
          }

          // Always reset flipped cards and canFlipThird after handling
          setFlippedCards([]);
          setCanFlipThird(false);
        },
        isMatch ? 300 : 1000
      );

      return () => clearTimeout(timer);
    }
  }, [flippedCards, cards, currentPlayerIndex, moveToNextPlayer]);

  // Wrap initializeGame in useCallback to avoid dependency issues
  const initializeGame = useCallback(() => {
    const newCards = generateCards();
    setCards(newCards);
    setFlippedCards([]);
    setMatchedSets([]);
    setCanFlipThird(false);
    setScore(0);
    setMoves(0);

    // Initialize player scores
    const newPlayerScores = gameConfig.players.map(() => 0);
    setPlayerScores(newPlayerScores);
    setCurrentPlayerIndex(0);
  }, [gameConfig.players, generateCards]);

  useEffect(() => {
    if (!modalOpened) {
      initializeGame();
    }
  }, [modalOpened, gameConfig, initializeGame]);

  // Handle reset from App component
  useEffect(() => {
    if (triggerReset) {
      // Clean up WebRTC connections if they exist
      if (webRTCServiceRef.current) {
        webRTCServiceRef.current.disconnect();
        webRTCServiceRef.current = null;
      }

      // Only show the game setup modal if we have a game mode selected
      if (gameMode) {
        setModalOpened(true);
      }
      onResetComplete();
    }
  }, [triggerReset, onResetComplete, gameMode]);

  // Initialize WebRTC for online play
  useEffect(() => {
    if (gameMode?.mode === "online" && gameMode?.roomId) {
      // Create WebRTC service if it doesn't exist
      if (!webRTCServiceRef.current) {
        webRTCServiceRef.current = new WebRTCService();

        // Set up event handlers
        if (webRTCServiceRef.current) {
          webRTCServiceRef.current.onPlayerJoined = (userId) => {
            setOnlineStatus((prev) => ({
              ...prev,
              players: [...prev.players, userId],
            }));
          };

          webRTCServiceRef.current.onPlayerLeft = (userId) => {
            setOnlineStatus((prev) => ({
              ...prev,
              players: prev.players.filter((id) => id !== userId),
            }));
          };

          webRTCServiceRef.current.onGameStateUpdate = (state) => {
            // Update local game state from received state
            if (state.cards) setCards(state.cards);
            if (state.flippedCards) setFlippedCards(state.flippedCards);
            if (state.matchedSets) setMatchedSets(state.matchedSets);
            if (state.playerScores) setPlayerScores(state.playerScores);
            if (state.currentPlayerIndex !== undefined)
              setCurrentPlayerIndex(state.currentPlayerIndex);
            if (state.moves !== undefined) setMoves(state.moves);
          };
          
          // Add connection status change handler
          webRTCServiceRef.current.onConnectionStatusChange = (status) => {
            console.log("Connection status changed:", status);
            setOnlineStatus((prev) => ({
              ...prev,
              connected: status.connected,
              error: status.error,
              connectionStatus: status,
            }));
          };
          
          // Connect to signaling server
          try {
            // Use the signaling server URL from environment variables
            const serverUrl = import.meta.env.VITE_SIGNALING_URL || "https://matchlet-signaling.onrender.com";
            const localUserId = webRTCServiceRef.current.connect(
              serverUrl,
              gameMode.roomId || "",
              !!gameMode.isHost
            );

            setOnlineStatus({
              connected: true,
              roomId: gameMode.roomId || null,
              isHost: !!gameMode.isHost,
              players: [localUserId],
              error: null,
              connectionStatus: webRTCServiceRef.current.getConnectionStatus(),
            });
          } catch (error) {
            console.error("Failed to connect to signaling server:", error);
            setOnlineStatus((prev) => ({
              ...prev,
              error: "Failed to connect to signaling server",
            }));
          }
        }
      }
    }

    // Cleanup function
    return () => {
      if (webRTCServiceRef.current) {
        webRTCServiceRef.current.disconnect();
      }
    };
  }, [gameMode]);

  // Handle game start from the GameSetupModal
  const handleStartGame = (config: GameConfigType) => {
    setGameConfig(config);
    setModalOpened(false);
    initializeGame();

    // If in online mode, sync the initial game state
    if (gameMode?.mode === "online" && webRTCServiceRef.current) {
      // Small delay to ensure state updates have been processed
      setTimeout(() => {
        const newCards = generateCards();
        webRTCServiceRef.current?.sendGameState({
          cards: newCards,
          flippedCards: [],
          matchedSets: [],
          playerScores: config.players.map(() => 0),
          currentPlayerIndex: 0,
          moves: 0,
        });
      }, 100);
    }
  };

  const resetGame = () => {
    // If in online mode and not the host, don't allow resetting
    if (gameMode?.mode === "online" && !gameMode.isHost) {
      return;
    }

    // Reset game state
    setCards([]);
    setFlippedCards([]);
    setMatchedSets([]);
    setPlayerScores(gameConfig.players.map(() => 0));
    setCurrentPlayerIndex(0);
    setMoves(0);
    setModalOpened(true);
  };
              )}
            </div>
          </div>
        </div>
        
        {onlineStatus.error && (
          <div className="tw-alert tw-alert-error tw-mt-2 tw-p-2 tw-text-sm">
            <span>{onlineStatus.error}</span>
            <h2 className="font-bubblegum text-primary mb-4 text-xl">
              Players
            </h2>
            <div className="space-y-4">
              {gameConfig.players.map((player, index) => (
                <div
                  key={index}
                  className={`flex items-center justify-between rounded-lg p-3 ${currentPlayerIndex === index ? "bg-base-300 shadow-md" : ""}`}
                >
                  <div className="flex items-center gap-3">
                    <div className="avatar">
                      <div
                        className={`ring-primary ring-offset-base-100 w-12 rounded-full ring ring-offset-2 ${currentPlayerIndex === index ? "tw-avatar-ping" : ""}`}
                      >
                        <img
                          src={
                            getAvatarUrl(player.avatar) ||
                            `${import.meta.env.BASE_URL || "/"}avatars/${player.avatar}`
                          }
                          alt={`${player.name}'s avatar`}
                        />
                      </div>
                    </div>
                    <div>
                      <p className="font-schoolbell text-lg">{player.name}</p>
                      <p className="text-sm">
                        Score:{" "}
                        <span className="font-bold">{playerScores[index]}</span>
                      </p>
                    </div>
                  </div>
                </div>
              ))}
            </div>
          </div>

          <div className="bg-base-200 mt-6 rounded-lg p-4 shadow-md">
            <h2 className="font-bubblegum text-primary mb-4 text-xl">
              Game Info
            </h2>
            <div className="space-y-2">
              <p className="font-comic text-lg">
                Moves: <span className="font-bold">{moves}</span>
              </p>
              
              {/* Connection Status UI */}
              {gameMode?.mode === "online" && (
                <div className="tw-mt-3">
                  <p className="font-comic text-lg">Room: <span className="tw-badge tw-badge-outline">{onlineStatus.roomId}</span></p>
                  
                  {/* Connection Status Badge */}
                  <div className="tw-flex tw-items-center tw-mt-2">
                    <span className="tw-mr-2">Status:</span>
                    {onlineStatus.connectionStatus?.connected ? (
                      <span className="tw-badge tw-badge-success">Connected</span>
                    ) : (
                      <span className="tw-badge tw-badge-error">Disconnected</span>
                    )}
                  </div>
                  
                  {/* Reconnection Attempts */}
                  {onlineStatus.connectionStatus?.reconnecting && (
                    <p className="tw-text-sm tw-mt-1">
                      Reconnecting... Attempt {onlineStatus.connectionStatus.reconnectAttempt}/{onlineStatus.connectionStatus.maxReconnectAttempts}
                    </p>
                  )}
                  
                  {/* Connection Error */}
                  {onlineStatus.error && (
                    <div className="tw-alert tw-alert-error tw-mt-2 tw-p-2 tw-text-sm">
                      <span>{onlineStatus.error}</span>
                    </div>
                  )}
                </div>
              )}
            </div>
          </div>
        </div>

        {/* Main game area */}
        <div className="bg-base-200/50 h-full overflow-y-auto rounded-lg p-4 shadow-inner md:col-span-3 lg:col-span-4">
          <div
            className={`grid gap-4 ${getGridColsClass(gameConfig.gridCols)} w-full auto-rows-min pb-4`}
          >
            {cards.map((card) => (
              <Card
                key={card.id}
                id={card.id}
                value={card.value}
                isFlipped={card.isFlipped}
                isMatched={card.isMatched}
                onClick={handleCardClick}
                disabled={isCardDisabled(card.id)}
                cardset={gameConfig.cardset}
              />
            ))}
          </div>

          {canFlipThird && flippedCards.length === 2 && (
            <div className="toast toast-end toast-bottom z-50">
              <div className="alert alert-success shadow-lg">
                <div>
                  <svg
                    xmlns="http://www.w3.org/2000/svg"
                    className="h-6 w-6 shrink-0 stroke-current"
                    fill="none"
                    viewBox="0 0 24 24"
                  >
                    <path
                      strokeLinecap="round"
                      strokeLinejoin="round"
                      strokeWidth="2"
                      d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"
                    />
                  </svg>
                  <span className="font-comic font-bold">
                    Cards match! You can flip a third card now.
                  </span>
                </div>
              </div>
            </div>
          )}

          {/* Matched Sets section removed as requested */}
        </div>
      </div>

      {/* Game Setup Modal */}
      <GameSetupModal
        opened={modalOpened}
        onClose={() => setModalOpened(false)}
        onStartGame={handleStartGame}
      />

      {/* ... rest of the code remains the same ... */}
    </div>
  );
};

export default Game;
